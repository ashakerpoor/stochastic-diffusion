Jan 11, 2012

Three differences in spine locator between 2.1.1 and 2.1.3.  Point 3 is causing the problem of spine labeling and stimulation.  This has been fixed.  Next step - build the executable (see build.xml by Robert) run a simulation, e.g. Uchi, using this fix, and then compare with an Uchi simulation using 2.1.1. (the simple problem shows no difference)

THEN, fix point 1 - this requires better understanding of getNormal and surfA

Perhaps before fixing point 1, if 2.1.3 is same as 2.1.1, then update stochasticgridcalc in 2.1.8 for andrew to use.  THEN, try to fix determ (probably the same in 2.1.1, 2.1.3, 2.1.8) and numbers of spines.
-----------------------------------------------------------------
Point 1 (common to both 2.1.1 and 2.1.3):
spineLocator.java, line 90: check to see whether the number of spines is greater than _half_ the number of surface compartments.  Not sure why 0.5* is being used.  Remove 0.5* (but keep the rest of the if statement and recalculation: nspines = (int) (0.5 * eltSA.length)) to allow 1 spine per surface compartment.  

>>>> remove 0.5, but now get error.  This line
           double abelow = rngen.random() * totalArea;
calculates where to put the spine.  The mesh file shows compartments extending from 1.0 to 7.67, but abelow is compared to the array: eltSA, which has 3 elements (corresponding to 3 voxles) of values 1.16, 2.33, 3.49.  Where did this come from?  They  came from surfA, which has 3 elements, each of value 1.1666, but what do those values represent?
They're obtained from getNormal, which does cross product of perimeter of surface.  For the first element, it appeared to use the second element, and calculated a normal of 1.1666 (from endpoints x=3.0 to 5.0). This is in geom.java.  Need to study this more before trying to fix this problem. 

Point 2 (difference, probably doesn't matter):
Random allocation of spine number has been changed from 2.1.1 to 2.1.3:
2.1.1:	// double nspines = RandomMath.poissonInt(avgNoSpines, rngen);
2.1.3	double nspines = avgNoSpines;
on line 80-90
Why are spine numbers now calculated deterministically?

Point 3: FIXED!!!!
line added to 2.1.3:
	ArrayList<Integer> positionA = new ArrayList<Integer>();

related difference in code:

2.1.1: arrayList is done within loop:
            if (gotSpine.contains(ip)) {
               // already got a spine - go round again;
            } else {
               gotSpine.add(ip);
               
               ArrayList<VolumeElement> elts = addSpineTo(surfVE.get(posInArray), sp.getProfile(), popid, ndone);
               volumeGrid.addElements(elts);
               ndone += 1;
            }  

2.1.3: arrayList done after the loop.  Using ndone which is always the last number!!!
	if (gotSpine.contains(ip)) {
		// already got a spine - go round again;
		} else {
		gotSpine.add(ip);
		positionA.add(ip);
		ndone += 1;
		}
	}
	Collections.sort(positionA);
				
	for (int posInArray : positionA) {
	    ArrayList<VolumeElement> elts = addSpineTo(surfVE.get(posInArray), sp.getProfile(), popid,	ndone);
		volumeGrid.addElements(elts);
	}


In 2.1.3, ndone is the last spine +1 when the arrayList and volumeGrid is added. This can't be done in the loop because the spines are sorted first, requiring them to all be created.  However we need to repeat the loop counter as follows:

	Collections.sort(positionA);

	ndone = 0;			
	for (int posInArray : positionA) {
	    ArrayList<VolumeElement> elts = addSpineTo(surfVE.get(posInArray), sp.getProfile(), popid,	ndone);
		volumeGrid.addElements(elts);
		ndone++;
	}
